<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Viewer - Razz v4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sf': ['-apple-system', 'BlinkMacSystemFont', 'SF Pro Display', 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', 'sans-serif'],
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-in-out',
                        'slide-up': 'slideUp 0.4s ease-out',
                        'pulse-soft': 'pulseSoft 2s ease-in-out infinite',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' },
                        },
                        slideUp: {
                            '0%': { transform: 'translateY(20px)', opacity: '0' },
                            '100%': { transform: 'translateY(0)', opacity: '1' },
                        },
                        pulseSoft: {
                            '0%, 100%': { opacity: '1' },
                            '50%': { opacity: '0.6' },
                        },
                    }
                }
            }
        }
    </script>
    <style>
        /* Minimal Apple-style effects */
        .glass-effect {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        /* Smooth minimal scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f5f5f7;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #d1d1d6;
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #a1a1a6;
        }
        
        /* Subtle camera card hover */
        .camera-card {
            transition: all 0.3s ease;
        }
        
        .camera-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
        }
        
        /* Person item animation */
        .person-item {
            animation: slideUp 0.4s ease-out;
        }
        
        /* Status indicator pulse */
        @keyframes status-pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.1);
            }
        }
        
        .status-live {
            animation: status-pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body class="bg-white font-sf text-gray-900">
    <div class="min-h-screen flex">
        <!-- People Sidebar - Minimal Apple Style -->
        <div id="peopleSidebar" class="w-80 bg-gray-50 border-r border-gray-200 flex flex-col overflow-hidden">
            <!-- Sidebar Header -->
            <div class="bg-white border-b border-gray-200 px-6 py-5">
                <h2 class="text-xl font-light text-gray-900 tracking-tight">Tracked People</h2>
                <p id="peopleCount" class="text-sm text-gray-600 mt-1 font-normal">0 people detected</p>
            </div>
            
            <!-- People List -->
            <div class="flex-1 overflow-y-auto p-4 space-y-2" id="peopleList">
                <div class="text-center py-12 text-gray-400">
                    <svg class="w-16 h-16 mx-auto mb-3 stroke-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path>
                    </svg>
                    <p class="text-sm font-light">No people detected yet</p>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex-1 flex flex-col">
            <!-- Header - Clean Minimal -->
            <div class="bg-white border-b border-gray-200 px-8 py-5">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-4">
                        <a href="/vault-room" class="text-gray-600 hover:text-gray-900 transition-colors duration-200">
                            <svg class="w-6 h-6 stroke-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                            </svg>
                        </a>
                        <div>
                            <h1 id="roomTitle" class="text-3xl font-extralight text-gray-900 tracking-tight">Loading...</h1>
                            <p class="text-sm text-gray-500 mt-1 font-light">Live Camera Streams</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <div class="flex items-center space-x-2 bg-green-50 px-3 py-1.5 rounded-full border border-green-200">
                            <div class="w-2 h-2 bg-green-500 rounded-full status-live"></div>
                            <span class="text-xs font-medium text-green-700">Live</span>
                        </div>
                        <button onclick="window.close()" class="px-5 py-2 bg-gray-900 hover:bg-gray-800 text-white text-sm font-medium transition-colors duration-200 rounded">
                            Close
                        </button>
                    </div>
                </div>
            </div>

            <!-- Camera Grid -->
            <div class="flex-1 p-8 overflow-y-auto bg-white">
                <div id="cameraGrid" class="grid grid-cols-1 md:grid-cols-2 gap-6 auto-rows-max">
                    <!-- Loading state -->
                    <div class="col-span-full flex items-center justify-center py-16">
                        <div class="text-center animate-fade-in">
                            <div class="inline-block animate-spin rounded-full h-10 w-10 border-t border-b border-gray-900 mb-4"></div>
                            <p class="text-gray-500 font-light">Loading camera streams...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get room ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('room_id');

            if (!roomId) {
            document.getElementById('cameraGrid').innerHTML = `
                <div class="col-span-full text-center py-12">
                    <p class="text-red-400">Error: No room ID provided</p>
                </div>
            `;
        } else {
            loadCameras();
        }

        async function loadCameras() {
            const cameraGrid = document.getElementById('cameraGrid');
            const roomTitle = document.getElementById('roomTitle');
            
            try {
                const response = await fetch(`/vault-rooms/${roomId}/cameras/webrtc`);
                
                if (!response.ok) {
                    throw new Error('Failed to load camera streams');
                }
                
                const data = await response.json();
                roomTitle.textContent = data.room_name;
                
                // Clear loading message
                cameraGrid.innerHTML = '';
                
                if (data.cameras.length === 0) {
                    cameraGrid.innerHTML = `
                        <div class="col-span-full text-center py-12">
                            <p class="text-gray-400">No active cameras found</p>
                        </div>
                    `;
                    return;
                }
                
                // Create video players for each camera
                data.cameras.forEach(camera => {
                    const cameraDiv = document.createElement('div');
                    cameraDiv.className = 'camera-card bg-white rounded overflow-hidden relative shadow-sm border border-gray-200 hover:border-gray-300';
                    
                    const videoId = `camera-video-${camera.id}`;
                    cameraDiv.innerHTML = `
                        <div class="relative" style="position: relative;">
                            <img id="${videoId}" class="w-full aspect-video bg-black object-contain" alt="Camera ${camera.id}" style="display: block;">
                            <canvas id="${videoId}-overlay" 
                                    class="absolute top-0 left-0" 
                                    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;">
                            </canvas>
                        </div>
                        <div class="absolute top-0 left-0 right-0 p-3" style="z-index: 20; pointer-events: none;">
                            <div class="flex items-center justify-between">
                                <p class="text-white font-light tracking-tight text-sm drop-shadow-lg">${escapeHtml(camera.name)}</p>
                                <div class="flex items-center space-x-1.5 bg-black/50 backdrop-blur-sm px-2 py-1 rounded-full">
                                    <div id="${videoId}-indicator" class="w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse"></div>
                                    <span id="${videoId}-status" class="text-white text-xs font-normal">Connecting...</span>
                                </div>
                            </div>
                            <div class="mt-2 flex items-center space-x-2">
                                <div class="bg-black/50 backdrop-blur-sm px-2.5 py-1 rounded-full">
                                    <div class="flex items-center space-x-1.5">
                                        <svg class="w-3.5 h-3.5 text-white stroke-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"></path>
                                        </svg>
                                        <span class="text-white text-xs font-medium" id="${videoId}-count">--</span>
                                    </div>
                                </div>
                                <div class="bg-black/50 backdrop-blur-sm px-2.5 py-1 rounded-full" id="${videoId}-tracking-badge" style="display: none;">
                                    <div class="flex items-center space-x-1.5">
                                        <svg class="w-3.5 h-3.5 text-white stroke-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                                        </svg>
                                        <span class="text-white text-xs font-medium" id="${videoId}-tracks">--</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="absolute bottom-0 left-0 right-0 p-3">
                            <div class="flex items-center justify-between">
                                <button onclick="toggleFullscreen('${videoId}')" class="text-white/80 hover:text-white transition-colors duration-200" style="z-index: 30; position: relative;">
                                    <svg class="w-4 h-4 stroke-1 drop-shadow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
                                    </svg>
                                </button>
                                <div class="flex items-center space-x-3">
                                    <button onclick="toggleTrackingStats('${videoId}', ${camera.id})" class="text-white/80 hover:text-white transition-colors duration-200 text-xs flex items-center space-x-1 bg-black/50 backdrop-blur-sm px-2.5 py-1 rounded-full" style="z-index: 30; position: relative;">
                                        <svg class="w-3.5 h-3.5 stroke-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 4 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                                        </svg>
                                        <span class="font-normal">Stats</span>
                                    </button>
                                    <span class="text-white/60 text-xs font-light drop-shadow">${escapeHtml(camera.rtsp_url.split('@')[1] || 'Stream')}</span>
                                </div>
                            </div>
                            <div id="${videoId}-stats-panel" class="mt-2 bg-black/70 backdrop-blur-md rounded-lg p-3 text-xs text-white hidden animate-slide-up">
                                <div class="grid grid-cols-2 gap-2">
                                    <div class="bg-white/10 rounded p-2">
                                        <span class="text-white/70 block mb-1 text-xs">Total Frames</span>
                                        <span class="text-white font-bold text-base" id="${videoId}-stat-frames">--</span>
                                    </div>
                                    <div class="bg-white/10 rounded p-2">
                                        <span class="text-white/70 block mb-1 text-xs">FPS</span>
                                        <span class="text-green-400 font-bold text-base" id="${videoId}-stat-fps">--</span>
                                    </div>
                                    <div class="bg-white/10 rounded p-2">
                                        <span class="text-white/70 block mb-1 text-xs">Active Tracks</span>
                                        <span class="text-blue-400 font-bold text-base" id="${videoId}-stat-active">--</span>
                                    </div>
                                    <div class="bg-white/10 rounded p-2">
                                        <span class="text-white/70 block mb-1 text-xs">Total Tracks</span>
                                        <span class="text-purple-400 font-bold text-base" id="${videoId}-stat-total">--</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    cameraGrid.appendChild(cameraDiv);
                    
                    // Initialize WebRTC + WebSocket tracking overlay
                    setTimeout(() => initWebRTCWithTracking(videoId, camera.id, camera.rtsp_url), 100);
                });
                
                // Start polling for people counts
                startPeopleCountPolling();

                // Fetch tracking badges once and then periodically
                fetchAndPopulateTrackingBadges();
                setInterval(fetchAndPopulateTrackingBadges, 5000);
                
            } catch (error) {
                cameraGrid.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <p class="text-red-400">Error loading cameras: ${error.message}</p>
                    </div>
                `;
            }
        }

        function initWebRTCWithTracking(videoId, cameraId, rtspUrl) {
            const img = document.getElementById(videoId);
            const canvas = document.getElementById(`${videoId}-overlay`);
            const ctx = canvas.getContext('2d');
            const status = document.getElementById(`${videoId}-status`);
            const indicator = document.getElementById(`${videoId}-indicator`);
            
            if (!img || !canvas) {
                console.error(`Elements not found for: ${videoId}`);
                return;
            }
            
            // Use nginx proxy paths for WebRTC and WebSocket
            const WEBRTC_URL = `${window.location.protocol}//${window.location.host}/webrtc`;
            const WS_URL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/tracking/${cameraId}`;
            
            let trackingData = { tracks: [] };
            let trackingWs = null;
            let useWebRTC = false;  // Flag to track if WebRTC is available
            
            // Step 1: Start WebRTC stream (30 FPS raw video)
            async function startWebRTC() {
                try {
                    // Get RTSP URL for this camera from the backend
                    const cameraInfoResponse = await fetch(`/vault-rooms/camera/${cameraId}/info`);
                    if (!cameraInfoResponse.ok) {
                        throw new Error(`Failed to get camera info: ${cameraInfoResponse.status}`);
                    }
                    
                    const cameraInfo = await cameraInfoResponse.json();
                    const rtspUrl = cameraInfo.rtsp_url;
                    
                    if (!rtspUrl) {
                        throw new Error('No RTSP URL found for camera');
                    }
                    
                    console.log(`Starting WebRTC for camera ${cameraId} with RTSP: ${rtspUrl}`);
                    
                    // Create RTCPeerConnection
                    const pc = new RTCPeerConnection({
                        iceServers: [
                            {urls: 'stun:stun.l.google.com:19302'},
                            {urls: 'stun:stun1.l.google.com:19302'},
                            {urls: 'stun:stun2.l.google.com:19302'}
                        ],
                        iceTransportPolicy: 'all'
                    });
                    
                    // Add transceiver to receive video
                    pc.addTransceiver('video', {'direction': 'recvonly'});
                    
                    // Handle incoming video track (set BEFORE creating offer)
                    pc.ontrack = (event) => {
                        console.log(`‚úÖ Received video track for camera ${cameraId}`, event.track);
                        console.log(`Track readyState: ${event.track.readyState}, enabled: ${event.track.enabled}`);
                        
                        const stream = event.streams[0] || new MediaStream([event.track]);
                        console.log(`Stream has ${stream.getTracks().length} tracks`);
                        
                        // Create video element dynamically for WebRTC (img tag won't work)
                        const videoElement = document.createElement('video');
                        videoElement.id = `${videoId}-webrtc`;
                        videoElement.autoplay = true;
                        videoElement.playsInline = true;
                        videoElement.muted = true; // Mute to avoid audio issues
                        videoElement.className = 'w-full aspect-video bg-black object-contain';
                        videoElement.style.display = 'block';
                        videoElement.srcObject = stream;
                        
                        // Add error handler
                        videoElement.onerror = (e) => {
                            console.error(`Video element error for camera ${cameraId}:`, e);
                        };
                        
                        // Replace img with video
                        img.parentElement.replaceChild(videoElement, img);
                        console.log(`Video element replaced for camera ${cameraId}`);
                        
                        // Set canvas size to match video
                        videoElement.onloadedmetadata = () => {
                            canvas.width = videoElement.videoWidth;
                            canvas.height = videoElement.videoHeight;
                            console.log(`Canvas size set: ${canvas.width}x${canvas.height}`);
                            
                            // Start drawing tracking overlay
                            requestAnimationFrame(drawTrackingOverlay);
                        };
                        
                        // Force play
                        videoElement.play().then(() => {
                            console.log(`Video playing for camera ${cameraId}`);
                        }).catch(err => {
                            console.error(`Failed to play video for camera ${cameraId}:`, err);
                        });
                        
                        if (status) status.textContent = 'Live';
                        if (indicator) indicator.className = 'w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse';
                    };
                    
                    pc.oniceconnectionstatechange = () => {
                        console.log(`ICE Connection State for camera ${cameraId}: ${pc.iceConnectionState}`);
                        if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
                            if (status) status.textContent = 'Disconnected';
                            if (indicator) indicator.className = 'w-1.5 h-1.5 bg-red-500 rounded-full';
                        } else if (pc.iceConnectionState === 'connected') {
                            if (status) status.textContent = 'Connected';
                            if (indicator) indicator.className = 'w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse';
                        }
                    };
                    
                    // Create offer
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    // Send offer to RTSPtoWebRTC server via nginx proxy
                    const sdp64 = btoa(offer.sdp);
                    
                    const formData = new FormData();
                    formData.append('url', rtspUrl);
                    formData.append('sdp64', sdp64);
                    
                    const response = await fetch('https://aqlinks.com/rtsp/stream', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`RTSPtoWebRTC returned ${response.status}: ${errorText}`);
                    }
                    
                    const data = await response.json();
                    console.log('Received answer from RTSPtoWebRTC - tracks:', data.tracks);
                    
                    // Set remote description with server's answer
                    const answerSdp = atob(data.sdp64);
                    await pc.setRemoteDescription(new RTCSessionDescription({
                        type: 'answer',
                        sdp: answerSdp
                    }));
                    
                    console.log(`WebRTC connection established for camera ${cameraId}`);
                    useWebRTC = true;
                    
                } catch (error) {
                    console.error(`WebRTC error for camera ${cameraId}:`, error);
                    if (status) status.textContent = 'Error';
                    if (indicator) indicator.className = 'w-1.5 h-1.5 bg-red-500 rounded-full';
                    useWebRTC = false;
                }
            }
            
            // Step 2: Connect WebSocket for tracking data (4-6 FPS)
            function connectTrackingWebSocket() {
                trackingWs = new WebSocket(WS_URL);
                
                trackingWs.onopen = () => {
                    console.log(`Tracking WebSocket connected for camera ${cameraId}`);
                };
                
                trackingWs.onmessage = (event) => {
                    try {
                        trackingData = JSON.parse(event.data);
                        // Update people count
                        const countEl = document.getElementById(`${videoId}-count`);
                        if (countEl && trackingData.stats) {
                            countEl.textContent = trackingData.stats.active_tracks;
                        }
                    } catch (error) {
                        console.error('Error parsing tracking data:', error);
                    }
                };
                
                trackingWs.onerror = (error) => {
                    console.error(`Tracking WebSocket error for camera ${cameraId}:`, error);
                };
                
                trackingWs.onclose = () => {
                    console.log(`Tracking WebSocket closed for camera ${cameraId}, reconnecting...`);
                    setTimeout(connectTrackingWebSocket, 3000);
                };
            }
            
            // Step 3: Draw tracking overlay on canvas (runs at 30 FPS for smooth animation)
            function drawTrackingOverlay() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw bounding boxes from tracking data
                if (trackingData && trackingData.tracks) {
                    trackingData.tracks.forEach(track => {
                        const [x1, y1, x2, y2] = track.bbox;
                        const width = x2 - x1;
                        const height = y2 - y1;
                        
                        // Scale coordinates to canvas size
                        const videoElement = document.getElementById(`${videoId}-webrtc`);
                        if (videoElement && videoElement.videoWidth > 0) {
                            const scaleX = canvas.width / videoElement.videoWidth;
                            const scaleY = canvas.height / videoElement.videoHeight;
                            
                            const scaledX = x1 * scaleX;
                            const scaledY = y1 * scaleY;
                            const scaledW = width * scaleX;
                            const scaledH = height * scaleY;
                            
                            // Draw box
                            ctx.strokeStyle = track.source === 'bytetrack' ? '#00ff00' : '#00ffff';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(scaledX, scaledY, scaledW, scaledH);
                            
                            // Draw label background
                            const label = `ID: ${track.track_id} (${Math.round(track.confidence * 100)}%)`;
                            ctx.font = '16px Arial';
                            const textWidth = ctx.measureText(label).width;
                            ctx.fillStyle = track.source === 'bytetrack' ? 'rgba(0, 255, 0, 0.8)' : 'rgba(0, 255, 255, 0.8)';
                            ctx.fillRect(scaledX, scaledY - 25, textWidth + 10, 25);
                            
                            // Draw label text
                            ctx.fillStyle = '#000000';
                            ctx.fillText(label, scaledX + 5, scaledY - 7);
                        }
                    });
                }
                
                // Continue animation loop
                requestAnimationFrame(drawTrackingOverlay);
            }
            
            // Start both streams
            startWebRTC();
            connectTrackingWebSocket();
        }

        function toggleFullscreen(videoId) {
            // Try to find video element first (WebRTC), then fallback to img (MJPEG)
            const videoElement = document.getElementById(`${videoId}-webrtc`) || document.getElementById(videoId);
            if (!videoElement) {
                console.error(`No video element found for ${videoId}`);
                return;
            }
            
            if (!document.fullscreenElement) {
                videoElement.parentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        function toggleTrackingStats(videoId, cameraId) {
            const statsPanel = document.getElementById(`${videoId}-stats-panel`);
            if (statsPanel.classList.contains('hidden')) {
                statsPanel.classList.remove('hidden');
                // Fetch initial stats
                updateTrackingStats(cameraId);
            } else {
                statsPanel.classList.add('hidden');
            }
        }
        
        async function updateTrackingStats(cameraId) {
            try {
                const response = await fetch(`/vault-rooms/${roomId}/tracking-stats`);
                if (!response.ok) return;
                
                const data = await response.json();
                
                // Find camera stats
                const cameraStats = data.cameras.find(c => c.camera_id === cameraId);
                if (!cameraStats || !cameraStats.tracking_enabled) return;
                
                const stats = cameraStats.statistics;
                const videoId = `camera-video-${cameraId}`;
                
                // Update stats display
                const framesEl = document.getElementById(`${videoId}-stat-frames`);
                const fpsEl = document.getElementById(`${videoId}-stat-fps`);
                const activeEl = document.getElementById(`${videoId}-stat-active`);
                const totalEl = document.getElementById(`${videoId}-stat-total`);
                
                if (framesEl) framesEl.textContent = stats.total_frames || 0;
                if (fpsEl) {
                    const fps = stats.avg_processing_time > 0 ? (1.0 / stats.avg_processing_time).toFixed(1) : '0.0';
                    fpsEl.textContent = fps;
                }
                if (activeEl) activeEl.textContent = stats.active_tracks || 0;
                if (totalEl) totalEl.textContent = stats.tracks_created || 0;
                
                // Update tracking badge
                const trackingBadge = document.getElementById(`${videoId}-tracking-badge`);
                const tracksEl = document.getElementById(`${videoId}-tracks`);
                if (trackingBadge && tracksEl) {
                    trackingBadge.style.display = 'block';
                    tracksEl.textContent = `${stats.active_tracks || 0} tracks`;
                }
            } catch (error) {
                console.error('Error fetching tracking stats:', error);
            }
        }

        async function fetchAndPopulateTrackingBadges() {
            try {
                const response = await fetch(`/vault-rooms/${roomId}/tracking-stats`);
                if (!response.ok) return;

                const data = await response.json();

                // For each camera returned, toggle the tracking badge and show active tracks
                data.cameras.forEach(cam => {
                    const videoId = `camera-video-${cam.camera_id}`;
                    const trackingBadge = document.getElementById(`${videoId}-tracking-badge`);
                    const tracksEl = document.getElementById(`${videoId}-tracks`);

                    if (cam.tracking_enabled && trackingBadge && tracksEl) {
                        const stats = cam.statistics || {};
                        trackingBadge.style.display = 'block';
                        tracksEl.textContent = `${stats.active_tracks || 0} tracks`;
                    } else if (trackingBadge) {
                        trackingBadge.style.display = 'none';
                    }
                });
            } catch (err) {
                console.debug('Could not fetch tracking badges:', err);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Poll for people count updates
        let peopleCountInterval;
        
        function startPeopleCountPolling() {
            // Initial fetch
            updatePeopleCounts();
            
            // Poll every 10 seconds
            peopleCountInterval = setInterval(updatePeopleCounts, 10000);
        }
        
        async function updatePeopleCounts() {
            try {
                const response = await fetch(`/vault-rooms/${roomId}/people-count`);
                if (!response.ok) return;
                
                const data = await response.json();
                
                // Update total count in header (optional)
                const roomTitle = document.getElementById('roomTitle');
                if (roomTitle && data.room_name) {
                    roomTitle.textContent = `${data.room_name} - ${data.total_people_count} people`;
                }
                
                // Update individual camera counts
                data.cameras.forEach(camera => {
                    const countElement = document.getElementById(`camera-video-${camera.camera_id}-count`);
                    if (countElement) {
                        const count = camera.people_count || 0;
                        countElement.textContent = `${count} ${count === 1 ? 'person' : 'people'}`;
                    }
                });
                
                // Update tracking stats for cameras with open stats panels
                document.querySelectorAll('[id$="-stats-panel"]:not(.hidden)').forEach(panel => {
                    const videoId = panel.id.replace('-stats-panel', '');
                    const cameraId = parseInt(videoId.split('-').pop());
                    updateTrackingStats(cameraId);
                });
                
            } catch (error) {
                console.error('Error fetching people counts:', error);
            }
        }
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (peopleCountInterval) {
                clearInterval(peopleCountInterval);
            }
            if (peopleDataInterval) {
                clearInterval(peopleDataInterval);
            }
            // Clean up tracking overlay intervals
            Object.values(trackingOverlayIntervals).forEach(interval => clearInterval(interval));
        });

        // Click-to-rename functionality
        let selectedPerson = null;
        let currentPeopleData = {};
        let peopleDataInterval = null;

        // Fetch and update people list
        async function updatePeopleData() {
            try {
                const response = await fetch(`/vault-rooms/${roomId}/people`);
                if (!response.ok) return;
                
                const data = await response.json();
                
                // Update sidebar
                updatePeopleSidebar(data.people, data.current_people_count);
                
                // Group by camera for any future use
                currentPeopleData = {};
                data.people.forEach(person => {
                    if (!currentPeopleData[person.camera_id]) {
                        currentPeopleData[person.camera_id] = [];
                    }
                    currentPeopleData[person.camera_id].push(person);
                });
            } catch (error) {
                console.error('Error fetching people:', error);
            }
        }

        // Update people sidebar with current detections
        function updatePeopleSidebar(people, count) {
            const peopleList = document.getElementById('peopleList');
            if (!peopleList || !peopleCount) return;
            
            peopleCount.textContent = `${count} ${count === 1 ? 'person' : 'people'} detected`;
            
            if (people.length === 0) {
                peopleList.innerHTML = `
                    <div class="text-center py-8 text-gray-500">
                        <svg class="w-12 h-12 mx-auto mb-2 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path>
                        </svg>
                        <p class="text-sm">No people detected</p>
                    </div>
                `;
                return;
            }
            
            // Group people by track_id (global ID) and collect their cameras
            const peopleMap = new Map();
            people.forEach(person => {
                if (!peopleMap.has(person.track_id)) {
                    peopleMap.set(person.track_id, {
                        ...person,
                        cameras: [person.camera_id]
                    });
                } else {
                    // Add this camera to the list if not already present
                    const existing = peopleMap.get(person.track_id);
                    if (!existing.cameras.includes(person.camera_id)) {
                        existing.cameras.push(person.camera_id);
                    }
                }
            });
            
            const uniquePeople = Array.from(peopleMap.values());
            
            peopleList.innerHTML = uniquePeople.map(person => {
                const displayName = person.name || `Person ${person.track_id}`;
                const initial = displayName.charAt(0).toUpperCase();
                const cameraList = person.cameras.sort((a, b) => a - b).join(', ');
                
                return `
                <div class="person-item group bg-white hover:bg-gray-50 rounded-lg p-3 transition-all duration-200 border border-gray-200 hover:border-gray-300">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-3 flex-1">
                            <div class="w-10 h-10 rounded-full bg-gray-900 flex items-center justify-center text-white font-light text-sm">
                                ${initial}
                            </div>
                            <div class="flex-1">
                                <div class="flex items-center space-x-2">
                                    <span class="font-normal text-gray-900 person-name tracking-tight text-sm" data-id="${person.track_id}">${displayName}</span>
                                    <button onclick="enableEditName('${person.track_id}', '${displayName}')" class="opacity-0 group-hover:opacity-100 text-gray-400 hover:text-gray-600 transition-opacity duration-200">
                                        <svg class="w-3.5 h-3.5 stroke-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path>
                                        </svg>
                                    </button>
                                </div>
                                <p class="text-xs text-gray-500 mt-0.5 font-light">ID: ${person.track_id} ‚Ä¢ Camera${person.cameras.length > 1 ? 's' : ''} ${cameraList}</p>
                            </div>
                        </div>
                    </div>
                </div>
            `}).join('');
        }

        // Enable inline name editing
        function enableEditName(globalId, currentName) {
            const nameSpan = document.querySelector(`.person-name[data-id="${globalId}"]`);
            if (!nameSpan) return;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.className = 'px-3 py-1.5 border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-gray-900 focus:border-gray-900 text-sm font-normal bg-white text-gray-900';
            input.style.width = '140px';
            
            // Save on Enter, cancel on Escape
            input.onkeydown = async (e) => {
                if (e.key === 'Enter') {
                    const newName = input.value.trim();
                    if (newName && newName !== currentName) {
                        await saveName(globalId, newName);
                    }
                    await updatePeopleData();
                } else if (e.key === 'Escape') {
                    await updatePeopleData();
                }
            };
            
            // Save on blur
            input.onblur = async () => {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    await saveName(globalId, newName);
                }
                await updatePeopleData();
            };
            
            nameSpan.replaceWith(input);
            input.focus();
            input.select();
        }

        // Save person name
        async function saveName(globalId, newName) {
            try {
                const response = await fetch(`/vault-rooms/${roomId}/rename-person`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ global_id: globalId, name: newName })
                });
                
                if (response.ok) {
                    console.log(`‚úÖ Renamed person ${globalId} to "${newName}"`);
                } else {
                    console.error('Failed to rename person');
                }
            } catch (error) {
                console.error('Error saving name:', error);
            }
        }

        // Draw clickable regions on canvas overlays
        function drawClickableOverlays() {
            Object.keys(currentPeopleData).forEach(cameraId => {
                const img = document.getElementById(`camera-video-${cameraId}`);
                const container = img?.parentElement;
                if (!container || !img) {
                    console.log(`‚ö†Ô∏è Container or image not found for camera ${cameraId}`);
                    return;
                }
                
                // Wait for image to load
                if (!img.complete || img.naturalWidth === 0) {
                    console.log(`‚è≥ Waiting for image to load for camera ${cameraId}`);
                    img.onload = () => drawClickableOverlays();
                    return;
                }
                
                // Remove old clickable divs
                const oldDivs = container.querySelectorAll('.person-clickable');
                oldDivs.forEach(div => div.remove());
                
                const people = currentPeopleData[cameraId];
                if (!people || people.length === 0) {
                    console.log(`‚ÑπÔ∏è No people data for camera ${cameraId}`);
                    return;
                }
                
                console.log(`Drawing overlays for camera ${cameraId}:`, {
                    imageNaturalSize: `${img.naturalWidth}x${img.naturalHeight}`,
                    imageDisplaySize: `${img.clientWidth}x${img.clientHeight}`,
                    peopleCount: people.length
                });
                
                people.forEach(person => {
                    if (!person.bbox) {
                        console.log(`‚ö†Ô∏è No bbox for person ${person.name}`);
                        return;
                    }
                    
                    const [x1, y1, x2, y2] = person.bbox;
                    
                    // Calculate scale accounting for object-contain letterboxing
                    const imgRatio = img.naturalWidth / img.naturalHeight;
                    const displayRatio = img.clientWidth / img.clientHeight;
                    
                    let scaleX, scaleY, offsetX = 0, offsetY = 0;
                    
                    if (imgRatio > displayRatio) {
                        // Image is wider - letterboxed top/bottom
                        scaleX = img.clientWidth / img.naturalWidth;
                        scaleY = scaleX;
                        offsetY = (img.clientHeight - (img.naturalHeight * scaleY)) / 2;
                    } else {
                        // Image is taller - letterboxed left/right
                        scaleY = img.clientHeight / img.naturalHeight;
                        scaleX = scaleY;
                        offsetX = (img.clientWidth - (img.naturalWidth * scaleX)) / 2;
                    }
                    
                    const scaledX = x1 * scaleX + offsetX;
                    const scaledY = y1 * scaleY + offsetY;
                    const scaledWidth = (x2 - x1) * scaleX;
                    const scaledHeight = (y2 - y1) * scaleY;
                    
                    console.log(`  Person ${person.name}: bbox=[${x1},${y1},${x2},${y2}] ‚Üí scaled=[${scaledX.toFixed(0)},${scaledY.toFixed(0)},${scaledWidth.toFixed(0)}x${scaledHeight.toFixed(0)}]`);
                    
                    // Create clickable DIV overlay
                    const div = document.createElement('div');
                    div.className = 'person-clickable';
                    div.style.cssText = `
                        position: absolute;
                        left: ${scaledX}px;
                        top: ${scaledY}px;
                        width: ${scaledWidth}px;
                        height: ${scaledHeight}px;
                        cursor: pointer;
                        z-index: 10;
                        border: 3px solid rgba(255, 215, 0, 0.8);
                        background: rgba(255, 215, 0, 0.15);
                        transition: all 0.2s ease;
                        box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
                    `;
                    
                    // Hover effect
                    div.addEventListener('mouseenter', function() {
                        this.style.background = 'rgba(255, 215, 0, 0.35)';
                        this.style.borderColor = 'rgba(255, 215, 0, 1)';
                        this.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.8)';
                        console.log(`üñ±Ô∏è Hover on: ${person.name}`);
                    });
                    
                    div.addEventListener('mouseleave', function() {
                        this.style.background = 'rgba(255, 215, 0, 0.15)';
                        this.style.borderColor = 'rgba(255, 215, 0, 0.8)';
                        this.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                    });
                    
                    // Click handler
                    div.addEventListener('click', function(e) {
                        e.stopPropagation();
                        console.log(`‚úÖ Click detected on: ${person.name} (Global ID: ${person.global_id})`);
                        showRenameModal(person.global_id, person.name, person.camera_id);
                    });
                    
                    // Name label
                    const label = document.createElement('div');
                    label.style.cssText = `
                        position: absolute;
                        top: 5px;
                        left: 5px;
                        background: rgba(0, 0, 0, 0.85);
                        color: #FFD700;
                        padding: 5px 10px;
                        border-radius: 6px;
                        font-size: 13px;
                        font-weight: bold;
                        pointer-events: none;
                        white-space: nowrap;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    `;
                    label.textContent = `${person.name} ÔøΩ`;
                    div.appendChild(label);
                    
                    // Click hint
                    const hint = document.createElement('div');
                    hint.style.cssText = `
                        position: absolute;
                        bottom: 5px;
                        left: 5px;
                        background: rgba(0, 0, 0, 0.75);
                        color: white;
                        padding: 3px 8px;
                        border-radius: 4px;
                        font-size: 10px;
                        pointer-events: none;
                    `;
                    hint.textContent = 'Click to rename';
                    div.appendChild(hint);
                    
                    container.appendChild(div);
                });
                
                console.log(`‚úÖ Created ${people.length} clickable overlays for camera ${cameraId}`);
            });
        }

        function showRenameModal(globalId, currentName, cameraId) {
            selectedPerson = { globalId, currentName, cameraId };
            
            const modal = document.getElementById('renameModal');
            const nameInput = document.getElementById('personNameInput');
            const currentNameSpan = document.getElementById('currentPersonName');
            
            currentNameSpan.textContent = currentName;
            nameInput.value = currentName;
            modal.classList.remove('hidden');
            nameInput.focus();
            
            // Pause updates while modal is open
            if (peopleUpdateInterval) {
                clearInterval(peopleUpdateInterval);
                peopleUpdateInterval = null;
            }
        }

        function closeRenameModal() {
            document.getElementById('renameModal').classList.add('hidden');
            selectedPerson = null;
            
            // Resume updates when modal is closed
            if (!peopleUpdateInterval) {
                peopleUpdateInterval = setInterval(updatePeopleData, 10000); // 10 seconds refresh
            }
        }

        async function savePersonName() {
            if (!selectedPerson) return;
            
            const nameInput = document.getElementById('personNameInput');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Please enter a name');
                return;
            }
            
            try {
                const response = await fetch(`/vault-rooms/${roomId}/rename-person`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        global_id: selectedPerson.globalId,
                        name: newName
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Person renamed:', data);
                    closeRenameModal();
                    // Refresh people data
                    await updatePeopleData();
                } else {
                    const error = await response.json();
                    alert(`Error: ${error.detail || 'Failed to rename person'}`);
                }
            } catch (error) {
                console.error('Error renaming person:', error);
                alert('Error renaming person');
            }
        }

        // Start updates with slower refresh rate
        let peopleUpdateInterval;
        updatePeopleData();
        peopleUpdateInterval = setInterval(updatePeopleData, 10000); // 10 seconds refresh
    </script>
</body>
</html>
