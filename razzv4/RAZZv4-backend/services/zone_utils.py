"""
Zone-based utilities for spatial awareness in tracking
Handles zone detection, person-in-zone checks, and overlap handling
"""

import json
from typing import Dict, List, Tuple, Optional
from logging_config import get_logger
from shapely.geometry import Point, Polygon
from shapely.ops import unary_union

logger = get_logger(__name__)


class ZoneManager:
    """Manages zones and detects which zone a person is in"""
    
    def __init__(self):
        self.zones_cache = {}  # {room_id: parsed_zones}
        self.overlap_cache = {}  # {room_id: overlap_data}
        logger.info("âœ… ZoneManager initialized")
    
    def load_zones_from_layout(self, room_id: int, room_layout_json: str) -> Dict:
        """
        Parse room layout JSON and extract zones
        
        Args:
            room_id: Room identifier
            room_layout_json: JSON string from database
            
        Returns:
            Dictionary with zones and overlaps
        """
        try:
            if not room_layout_json:
                logger.warning(f"No room layout for room {room_id}")
                return {'zones': [], 'overlaps': []}
            
            layout = json.loads(room_layout_json)
            zones = []
            overlaps = layout.get('overlaps', [])
            
            # Extract zone objects
            for obj in layout.get('objects', []):
                if obj.get('type') == 'zone' and obj.get('points'):
                    zone_data = {
                        'id': obj.get('id'),
                        'camera_id': obj.get('cameraId'),
                        'points': obj['points'],
                        'polygon': self._create_polygon(obj['points']),
                        'auto_generated': obj.get('autoGenerated', False)
                    }
                    zones.append(zone_data)
            
            # Cache the zones
            self.zones_cache[room_id] = zones
            self.overlap_cache[room_id] = overlaps
            
            logger.info(f"ðŸ“ Room {room_id}: Loaded {len(zones)} zones, {len(overlaps)} overlaps")
            return {'zones': zones, 'overlaps': overlaps}
            
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse room layout for room {room_id}: {e}")
            return {'zones': [], 'overlaps': []}
        except Exception as e:
            logger.error(f"Error loading zones for room {room_id}: {e}")
            return {'zones': [], 'overlaps': []}
    
    def _create_polygon(self, points: List[Dict]) -> Polygon:
        """Create Shapely polygon from points list"""
        try:
            coords = [(p['x'], p['y']) for p in points]
            return Polygon(coords)
        except Exception as e:
            logger.error(f"Failed to create polygon: {e}")
            return None
    
    def get_person_zone(self, room_id: int, x: float, y: float) -> Optional[Dict]:
        """
        Determine which zone a person is in based on their position
        
        Args:
            room_id: Room identifier
            x, y: Person's position in meters (world coordinates)
            
        Returns:
            Zone dictionary if person is in a zone, None otherwise
        """
        if room_id not in self.zones_cache:
            logger.warning(f"No zones cached for room {room_id}")
            return None
        
        point = Point(x, y)
        zones = self.zones_cache[room_id]
        
        # Check which zone(s) contain this point
        matching_zones = []
        for zone in zones:
            if zone['polygon'] and zone['polygon'].contains(point):
                matching_zones.append(zone)
        
        if not matching_zones:
            return None
        
        # If in multiple zones (overlap area), return the first one
        # You could implement priority logic here
        return matching_zones[0]
    
    def is_in_overlap(self, room_id: int, x: float, y: float) -> Optional[Dict]:
        """
        Check if a person is in an overlap area
        
        Args:
            room_id: Room identifier
            x, y: Person's position
            
        Returns:
            Overlap data if in overlap, None otherwise
        """
        if room_id not in self.overlap_cache:
            return None
        
        point = Point(x, y)
        overlaps = self.overlap_cache[room_id]
        
        for overlap in overlaps:
            if overlap.get('points'):
                overlap_polygon = self._create_polygon(overlap['points'])
                if overlap_polygon and overlap_polygon.contains(point):
                    return overlap
        
        return None
    
    def get_zone_statistics(self, room_id: int, tracked_people: List[Dict]) -> Dict:
        """
        Calculate statistics for each zone
        
        Args:
            room_id: Room identifier
            tracked_people: List of tracked persons with positions
            
        Returns:
            Dictionary with zone statistics
        """
        if room_id not in self.zones_cache:
            return {}
        
        zones = self.zones_cache[room_id]
        stats = {}
        
        for zone in zones:
            zone_id = zone['id']
            stats[zone_id] = {
                'camera_id': zone.get('camera_id'),
                'people_count': 0,
                'people_ids': [],
                'in_overlap': []
            }
        
        # Count people in each zone
        for person in tracked_people:
            x, y = person.get('x', 0), person.get('y', 0)
            zone = self.get_person_zone(room_id, x, y)
            
            if zone:
                zone_id = zone['id']
                stats[zone_id]['people_count'] += 1
                stats[zone_id]['people_ids'].append(person.get('global_id'))
                
                # Check if in overlap
                overlap = self.is_in_overlap(room_id, x, y)
                if overlap:
                    stats[zone_id]['in_overlap'].append({
                        'person_id': person.get('global_id'),
                        'overlap_id': overlap.get('id'),
                        'area': overlap.get('area', 0)
                    })
        
        return stats
    
    def convert_bbox_to_world_coords(self, bbox: Tuple[float, float, float, float], 
                                     camera_position: Tuple[float, float],
                                     scale: float = 20.0) -> Tuple[float, float]:
        """
        Convert bounding box center to world coordinates
        
        Args:
            bbox: (x1, y1, x2, y2) in pixels
            camera_position: (cam_x, cam_y) in meters
            scale: Pixels per meter
            
        Returns:
            (world_x, world_y) in meters
        """
        # Get center of bounding box in pixels
        center_x = (bbox[0] + bbox[2]) / 2
        center_y = (bbox[1] + bbox[3]) / 2
        
        # Convert to meters relative to camera
        # This is simplified - you may need more sophisticated transformation
        relative_x = center_x / scale
        relative_y = center_y / scale
        
        # Add camera position
        world_x = camera_position[0] + relative_x
        world_y = camera_position[1] + relative_y
        
        return world_x, world_y


# Global instance
zone_manager = ZoneManager()
