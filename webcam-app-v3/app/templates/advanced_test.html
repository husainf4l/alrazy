<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Advanced Camera Monitoring System - WebRTC Streaming">
    <title>Advanced Test - WebRTC Camera Monitoring</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #f5f5f5;
        }

        .camera-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        @media (min-width: 768px) {
            .camera-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (min-width: 1024px) {
            .camera-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 1536px) {
            .camera-grid {
                grid-template-columns: repeat(5, 1fr);
            }
        }

        .camera-card {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .camera-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 75%;
            background: #000;
            overflow: hidden;
        }

        .video-container video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .camera-info {
            padding: 1rem;
        }

        .camera-name {
            font-weight: 600;
            color: #1f2937;
            font-size: 0.95rem;
        }

        .camera-status {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        .status-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 10;
        }

        .stats-display {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            color: #10b981;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: 600;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            display: inline-block;
        }

        .dot-connected {
            background: #10b981;
        }

        .dot-loading {
            background: #3b82f6;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .dot-error {
            background: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="bg-gray-100">
    {% include 'components/sidebar.html' %}

    <!-- Main Content Area -->
    <div class="lg:ml-64">
        <div class="p-4 md:p-8">
            <div class="mb-6">
                <h1 class="text-3xl font-light text-gray-900">Advanced Test - WebRTC</h1>
                <p class="text-gray-600 text-sm mt-1">Real-time camera monitoring with low-latency WebRTC streaming</p>
            </div>

            <!-- Camera Grid -->
            <div class="camera-grid" id="cameraGrid">
                <!-- Loading placeholders -->
                <div class="camera-card">
                    <div class="video-container bg-gray-300 animate-pulse"></div>
                </div>
                <div class="camera-card">
                    <div class="video-container bg-gray-300 animate-pulse"></div>
                </div>
                <div class="camera-card">
                    <div class="video-container bg-gray-300 animate-pulse"></div>
                </div>
                <div class="camera-card">
                    <div class="video-container bg-gray-300 animate-pulse"></div>
                </div>
                <div class="camera-card">
                    <div class="video-container bg-gray-300 animate-pulse"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            ICE_SERVERS: [
                { urls: ['stun:stun.l.google.com:19302'] }
            ],
            STATS_INTERVAL: 1000,
            RECONNECT_DELAY: 3000,
            REQUEST_TIMEOUT: 10000,
            FRAME_POLL_INTERVAL: 8,  // 8ms for high FPS, optimal for most connections
            JPEG_QUALITY: 80,  // Balance between quality and bandwidth
            MAX_CONCURRENT_REQUESTS: 1,  // Per camera - non-blocking
            FRAME_CACHE_TTL: 16,  // Cache frame for 16ms to handle burst requests
            // Adaptive quality tuning
            QUALITY_HIGH: 85,
            QUALITY_MEDIUM: 80,
            QUALITY_LOW: 70,
            LATENCY_THRESHOLD_MEDIUM: 50,  // Switch to medium quality if latency > 50ms
            LATENCY_THRESHOLD_LOW: 100  // Switch to low quality if latency > 100ms
        };

        // Global state
        const state = {
            cameras: {},
            sessions: {},
            peerConnections: {},
            stats: {},
            latency: {}  // Track network latency per camera for adaptive quality
        };

        // Utility: Get auth token
        function getToken() {
            return localStorage.getItem('token');
        }

        // Utility: Check authentication
        function checkAuth() {
            const token = getToken();
            if (!token) {
                window.location.href = '/login';
                return false;
            }
            return token;
        }

        // Utility: Make fetch request with timeout and auth
        async function fetchWithAuth(url, options = {}) {
            const token = getToken();
            const timeout = options.timeout || CONFIG.REQUEST_TIMEOUT;

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal,
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        // Initialize camera UI
        async function initializeCameras() {
            try {
                if (!checkAuth()) return;

                // First: Initialize cameras from config
                console.log('Initializing cameras from config...');
                const initResponse = await fetchWithAuth('/api/ip-cameras/initialize', {
                    method: 'POST'
                });
                
                if (!initResponse.ok) {
                    throw new Error(`Failed to initialize cameras: ${initResponse.status}`);
                }
                
                const initData = await initResponse.json();
                console.log('Initialization result:', initData);

                // Second: Get camera list from backend
                const response = await fetchWithAuth('/api/ip-cameras/status');
                const data = await response.json();

                if (data.cameras) {
                    state.cameras = data.cameras;
                    renderCameraCards();
                    console.log(`Loaded ${Object.keys(data.cameras).length} cameras`);
                }
            } catch (error) {
                console.error('Camera initialization error:', error);
            }
        }

        // Render camera cards
        function renderCameraCards() {
            const grid = document.getElementById('cameraGrid');
            grid.innerHTML = '';

            Object.entries(state.cameras).forEach(([name, camera]) => {
                const card = document.createElement('div');
                card.className = 'camera-card';
                card.id = `card-${name}`;
                card.innerHTML = `
                    <div class="video-container relative">
                        <!-- Image will be injected here by pollFrames() -->
                        <div class="status-badge">
                            <span class="dot dot-loading" id="status-dot-${name}"></span>
                            <span id="status-text-${name}">Disconnected</span>
                        </div>
                        <div class="stats-display" id="stats-${name}">
                            <span id="bitrate-${name}">-- fps</span>
                            <span id="resolution-${name}">-- p</span>
                        </div>
                    </div>
                    <div class="camera-info">
                        <h3 class="camera-name">${name}</h3>
                        <p class="camera-status" id="info-${name}">Initializing...</p>
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        // Connect camera via simple HTTP frame polling
        async function connectCamera(cameraName) {
            try {
                updateCameraStatus(cameraName, 'connecting', 'Connecting...');

                // Start frame polling loop
                await pollFrames(cameraName);

            } catch (error) {
                console.error(`Error connecting ${cameraName}:`, error);
                updateCameraStatus(cameraName, 'error', 'Connection failed');
                // Attempt reconnect
                setTimeout(() => connectCamera(cameraName), CONFIG.RECONNECT_DELAY);
            }
        }

        // Poll frames from camera with optimized timing for low-latency 30+ FPS
        async function pollFrames(cameraName) {
            const videoContainer = document.querySelector(`#card-${cameraName} .video-container`);
            if (!videoContainer) return;

            // Create or get the image element
            let frameImg = videoContainer.querySelector('img[data-camera-frame]');
            if (!frameImg) {
                frameImg = document.createElement('img');
                frameImg.setAttribute('data-camera-frame', 'true');
                frameImg.style.display = 'none';
                frameImg.style.backfaceVisibility = 'hidden';  // GPU acceleration
                frameImg.style.willChange = 'contents';  // Hint for browser optimization
                videoContainer.appendChild(frameImg);
            }

            let frameCount = 0;
            let startTime = Date.now();
            let requestInProgress = false;
            let lastFrameTime = 0;
            let currentQuality = CONFIG.QUALITY_HIGH;
            let latencySum = 0;
            let latencySamples = 0;
            let lastEtag = null;  // Track ETag for frame deduplication

            const pollLoop = async () => {
                // Non-blocking polling - skip if request in progress
                if (requestInProgress) {
                    setTimeout(pollLoop, 0);
                    return;
                }

                requestInProgress = true;
                const requestStartTime = Date.now();

                try {
                    // Smart timeout based on network conditions
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 2000);

                    const response = await fetch(`/api/ip-cameras/frame/${cameraName}?quality=${currentQuality}`, {
                        headers: {
                            'Authorization': `Bearer ${getToken()}`,
                            'Cache-Control': 'no-cache'
                        },
                        signal: controller.signal,
                        method: 'GET'
                    });

                    clearTimeout(timeout);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // Track latency for adaptive quality
                    const responseLatency = Date.now() - requestStartTime;
                    latencySum += responseLatency;
                    latencySamples++;
                    
                    if (latencySamples >= 10) {
                        const avgLatency = latencySum / latencySamples;
                        state.latency[cameraName] = avgLatency;
                        
                        // Adaptive quality adjustment
                        if (avgLatency > CONFIG.LATENCY_THRESHOLD_LOW) {
                            currentQuality = CONFIG.QUALITY_LOW;  // Reduce quality for slow networks
                        } else if (avgLatency > CONFIG.LATENCY_THRESHOLD_MEDIUM) {
                            currentQuality = CONFIG.QUALITY_MEDIUM;
                        } else {
                            currentQuality = CONFIG.QUALITY_HIGH;  // Good network, use high quality
                        }
                        
                        latencySum = 0;
                        latencySamples = 0;
                    }

                    // Update frame if available
                    if (data.frame) {
                        const now = Date.now();
                        // Always update frame for live streaming (no ETag dedup)
                        frameImg.src = data.frame;
                        frameImg.style.display = 'block';
                        lastFrameTime = now;
                        frameCount++;

                        // Update stats every 30 frames
                        if (frameCount % 30 === 0) {
                            const elapsed = (Date.now() - startTime) / 1000;
                            const fps = Math.round(frameCount / elapsed);
                            updateStatsDisplay(cameraName, fps);
                        }

                        // Update status on first frame
                        if (frameCount === 1) {
                            updateCameraStatus(cameraName, 'connected', 'Connected');
                        }
                    }
                } catch (error) {
                    if (frameCount === 0) {
                        console.error(`Frame polling error for ${cameraName}:`, error.message);
                        updateCameraStatus(cameraName, 'error', 'Connection lost');
                    }
                } finally {
                    requestInProgress = false;
                    
                    // Adaptive timing based on network response
                    const responseTime = Date.now() - requestStartTime;
                    const adaptiveDelay = Math.max(CONFIG.FRAME_POLL_INTERVAL, responseTime / 2);
                    
                    // Continue polling with adaptive delay
                    setTimeout(pollLoop, adaptiveDelay);
                }
            };

            // Start polling immediately
            pollLoop();
        }

        // Quick stats display update
        function updateStatsDisplay(cameraName, fps) {
            const fpsEl = document.getElementById(`bitrate-${cameraName}`);
            if (fpsEl) {
                fpsEl.textContent = `${fps} fps`;
            }
        }

        // Update stats display
        function updateStats(cameraName, width, height) {
            if (!state.stats[cameraName]) {
                state.stats[cameraName] = {
                    startTime: Date.now(),
                    frames: 0
                };
            }

            state.stats[cameraName].frames++;

            const elapsed = (Date.now() - state.stats[cameraName].startTime) / 1000;
            const fps = Math.round(state.stats[cameraName].frames / elapsed);

            const bitrateEl = document.getElementById(`bitrate-${cameraName}`);
            const resolutionEl = document.getElementById(`resolution-${cameraName}`);

            if (bitrateEl) {
                bitrateEl.textContent = `${fps} fps`;
            }
            if (resolutionEl && height) {
                resolutionEl.textContent = `${height}p`;
            }
        }

        // Update camera status display
        function updateCameraStatus(cameraName, status, message) {
            const statusDot = document.getElementById(`status-dot-${cameraName}`);
            const statusText = document.getElementById(`status-text-${cameraName}`);
            const info = document.getElementById(`info-${cameraName}`);

            const statusClass = {
                'connected': 'dot-connected',
                'connecting': 'dot-loading',
                'error': 'dot-error'
            };

            if (statusDot) {
                statusDot.className = `dot ${statusClass[status] || 'dot-error'}`;
                statusText.textContent = message;
            }

            if (info) {
                const iconMap = {
                    'connected': '✓',
                    'connecting': '⏳',
                    'error': '✕'
                };
                info.textContent = `${iconMap[status] || ''} ${message}`;
            }

            console.log(`${cameraName}: ${status} - ${message}`);
        }

        // Disconnect camera
        async function disconnectCamera(cameraName) {
            try {
                const video = document.getElementById(`video-${cameraName}`);
                if (video) {
                    video.srcObject = null;
                }
                updateCameraStatus(cameraName, 'error', 'Disconnected');
            } catch (error) {
                console.error(`Error disconnecting ${cameraName}:`, error);
            }
        }

        // Connect all cameras
        async function connectAllCameras() {
            for (const cameraName of Object.keys(state.cameras)) {
                await connectCamera(cameraName);
                // Stagger connections slightly
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }

        // Disconnect all cameras
        async function disconnectAllCameras() {
            for (const cameraName of Object.keys(state.cameras)) {
                await disconnectCamera(cameraName);
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            disconnectAllCameras().catch(console.error);
        });

        // Initialize on page load - auto-connect all cameras
        document.addEventListener('DOMContentLoaded', () => {
            if (checkAuth()) {
                initializeCameras().then(() => {
                    // Auto-connect all cameras immediately
                    connectAllCameras();
                });
            }
        });
    </script>
</body>
</html>
